# Explanation 7
As mentioned in the explanation for [problem 5](../problem_5/explanation_5.md), I do not believe this problem prompt provided enough context to inform the focus of this explanation. I have chosen to focus on the `add_handler` and `lookup` methods of the `Router` class as they represent the public api for this solution. If this does not meet the requirements for the project due to content coverage, I ask again that the project description be updated to explicitly mention what Udacity reviews are expecting. 
## Rationale
For the "HTTPRouter using a Trie" problem. I leveraged a Trie as mandated by the requirements. The `RouteTrieNode` constructor leverages Python's `defaultdict` class to streamline the addition of new nodes.

## Runtime Analysis
1. `add_handler` - The `add_handler` method of the `Router` class has a runtime complexity and space complexity of `O(n)` where `n` represents the number of non-empty path segments present in the input path. The runtime scales linearly with segments derived from the input path as we extend the underlying Trie, adding a new node per segment in the worst case. The same applies to memory utilization in the worst case as adding handlers for paths that do not share a common path from root results in a new node instantiated per segment.
2. `lookup` - The `lookup` method of the `Router` class has a runtime complexity and space complexity of `O(n)` where `n` represents the number of non-empty path segments present in the input path. In the worst case, the runtime scales linearly with the aformentioned path segments but is amortized by the Router's existing state in the average case. During a lookup operation; if it is determined that we have no children at our current node but remaining path segements are greater than zero, we terminate early and return `None` to signal the path is not defined. Memory utilization also scales with the segments present in the input path as we leverage recursion to traverse the underlying Trie.

### Additional Notes after 1st Review
As mentioned at the head of this document, I believe this prompt was lacking detail on what to focus the explanation on. The reviewer insisted including runtime analysis for every component, that follows below:

1. `RouteTrieNode` constructor - Has a runtime and space complexity of `O(1)` as the contructor's input has no significant bearing on runtime and memory utilization
2. `RouteTrie` constructor - Has a runtime and space complexity of `O(1)` as the contructor's input has no significant bearing on runtime and memory utilization
3. `RouteTrie` `insert` method -  Has a runtime and space complexity of `O(n)` where `n` represents the number of path segments passed in as input. Space complexity is also linear as the depth of recursion and new `RouteTrieNode` objects created scale linearly with the the number of path segements passed.
4. `RouteTrie` `find` method - Has a runtime and space complexity of `O(n)` where `n` represents the number of path segements passed in as input.
5. `Router` constructor - Has a runtime and space complexity of `O(1)` as the contructor's input has no significant bearing on runtime and memory utilization
5. `Router` `add_handler` method - As mentioned in the previous section: The `add_handler` method of the `Router` class has a runtime complexity and space complexity of `O(n)` where `n` represents the number of non-empty path segments present in the input path. `add_handler` wraps the aformentioned `RouteTrie`'s `insert` method
5. `Router` `lookup` method - As mentioned in the previous section: The `lookup` method of the `Router` class has a runtime complexity and space complexity of `O(n)` where `n` represents the number of non-empty path segments present in the input path. `lookup` wraps the aformentioned `RouteTrie`'s `find` method.
5. `Router` `split_path` method - Has a runtime and space complexity of `O(n)` where n represents the character length of the provided path.