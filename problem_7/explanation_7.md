# Explanation 7
As mentioned in the explanation for [problem 5](../problem_5/explanation_5.md), I do not believe this problem prompt provided enough context to inform the focus of this explanation. I have chosen to focus on the `add_handler` and `lookup` methods of the `Router` class as they represent the public api for this solution. If this does not meet the requirements for the project due to content coverage, I ask again that the project description be updated to explicitly mention what Udacity reviews are expecting. 
## Rationale
For the "HTTPRouter using a Trie" problem. I leveraged a Trie as mandated by the requirements. The `RouteTrieNode` constructor leverages Python's `defaultdict` class to streamline the addition of new nodes.

## Runtime Analysis
1. `add_handler` - The `add_handler` method of the `Router` class has a runtime complexity and space complexity of `O(n)` where `n` represents the number of non-empty path segments present in the input path. The runtime scales linearly with segments derived from the input path as we extend the underlying Trie, adding a new node per segment in the worst case. The same applies to memory utilization in the worst case as adding handlers for paths that do not share a common path from root results in a new node instantiated per segment.
2. `lookup` - The `lookup` method of the `Router` class has a runtime complexity and space complexity of `O(n)` amortized where `n` represents the number of non-empty path segments present in the input path. The runtime scales linearly with the aformentioned path segments but is amortized by the Router's existing state. During a lookup operation; if it is determined that we have no children at our current node but remaining path segements are greater than zero, we terminate early and return `None` to signal the path is not defined. Memory utilization also scales with the segments present in the input path as we leverage recursion to traverse the underlying Trie.